\documentclass[twocolumn,hidelinks]{article}
\usepackage{orcidlink}
\usepackage[
    type={CC},
    modifier={by},
    version={4.0},
    imagedistance={.5em},
    %imagewidth={5.5em},
    %imagemodifier={-80x15},
]{doclicense}
\usepackage[margin=1in,columnsep=1em]{geometry}
\usepackage{enumitem} % to control gaps in description lists
\usepackage{url}
\usepackage[acronym]{glossaries}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{complexity}
\usepackage{cancel}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{nicematrix}
\newcommand{\baheem}{Băhēm}
\newcommand{\alyal}{Alyal}
\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}
\DeclareMathOperator{\random}{random}
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\dec}{dec}
\DeclareMathOperator{\fread}{read}
\DeclareMathOperator{\fwrite}{write}
\DeclareMathOperator{\entropy}{H}
\makeglossaries
\newacronym{trng}{TRNG}{true random number generator}
\newacronym{otp}{OTP}{one-time pad}
\newacronym{xor}{XOR}{bitwise exclusive-or operation}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{note}{Note}
\renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\pq}[1]{\cellcolor{red!20}#1}
\newcommand{\ph}[1]{\cellcolor{blue!20}#1}
\newcommand{\qh}[1]{\cellcolor{green!20}#1}
\usepackage{cleveref} % must be loaded last
\begin{document}

\begin{center}
    \Huge
    \baheem\\
    \Large
    Provably Secure Symmetric Cipher\\
    \normalsize
    \vspace{0.5em}
    M. Rajululkahf\,\orcidlink{0000-0001-9061-2921}\footnote{Author's e-mail address: \{last
    name\}\url{@pm.me}}\\
    \vspace{0.5em}
    \footnotesize
    \today\\
\end{center}

\section*{Overview}
This paper proposes \baheem;  a symmetric cipher that, when given a
random-looking key $\mathbf{k}$, a \gls{trng} and a cleartext message
$\mathbf{m}$ to encrypt, no cryptanalysis can degrade its security below
$\min(\entropy(\mathbf{m}), \entropy(\mathbf{k}))$ bits of entropy, even
under Grover's algorithm \cite{10.1145/237814.237866} or even if it turned
out that $\P = \NP$.

Aside from the cost of memory access and input/output processing, \baheem\
is also highly parallelise-able, and requires only three additions and one
\gls{xor} in order to encrypt or decrypt.

Its early prototype, \alyal, achieved similar run-time speeds to OpenSSL's
ChaCha20 \cite{chacha20}; slightly faster decryption, while slightly slower
encryption when the \gls{trng} was prepared in a file in advance.  Future
versions, with better \gls{trng} optimisations, should be able to enable
the prototype to have faster run-time for both, encryption and decryption,
alike.  Either way, \alyal\ is highly practical, specially when considering
its strong security guarantee.  Further speed gain is possible when \alyal\
utilises \baheem's high parallelism.

\section*{Notation}
\begin{description}[itemsep=0em]
    \item[$\entropy(\mathbf{x})$:]  Shannon's entropy of random variable
        $\mathbf{x}$.

    \item[$\mathbf{x} + \mathbf{y} \bmod{2^{128}}$:]  Unsigned $128$-bit
        addition.

    \item[$\random(128)$:]  A sequence of $128$ many random bits generated
        by a \gls{trng}.

    \item[$\mathbf{k}$:]  A $128$-bit pre-shared secret key with enough
        $\entropy(\mathbf{k})$ that looks random.  Ideally $\mathbf{k} =
        \random(128)$.

    \item[$\mathbf{m}$:]  An arbitrarily-long cleartext message of
        $|\mathbf{m}|$ many bits.

    \item[$\lceil\frac{|\mathbf{m}|}{128}\rceil$:]  Number of $128$-bit
        blocks in cleartext $\mathbf{m}$.

    \item[$\mathbf{m}_b$:]  The $b^{\text{th}}$ $128$-bit block from
        $\mathbf{m}$.

    \item[$\mathbf{p}_b = \random(128), \mathbf{q}_b = \random(128)$:]  A
        pair of uniformly distributed $128$ many random bits.

    \item[$\mathbf{\hat p}_b, \mathbf{\hat q}_b, \mathbf{\hat m}_b$:]
        Encrypted forms of $\mathbf{p}_b$, $\mathbf{q}_b$ and
        $\mathbf{m}_b$, respectively.
\end{description}

%\vfill
\break

\tableofcontents

\blfootnote{\vspace{-1em}\doclicenseThis}

\section{Proposed Algorithm}
\Cref{alg_enc,alg_dec} show \baheem's encryption and decryption by which
the process is repeated over every $128$-bit blocks of $\mathbf{m}$.

\begin{algorithm}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{$\mathbf{k}, \mathbf{m}_0, \mathbf{m}_1, \ldots$}
    \Output{$
        (\mathbf{\hat p}_0, \mathbf{\hat q}_0, \mathbf{\hat m}_0),
        (\mathbf{\hat p}_1, \mathbf{\hat q}_1, \mathbf{\hat m}_1),
        \ldots
    $}
    \hrulefill\\
    \For{$b \in (0, 1, \ldots, \lceil\frac{|\mathbf{m}|}{128}\rceil-1)$}{
        $\mathbf{p}_b \gets \random(128)$\\
        $\mathbf{q}_b \gets \random(128)$\\
        $\mathbf{\hat p}_b
            \gets \mathbf{p}_b + \mathbf{k}
            \bmod{2^{128}}$\\
        $\mathbf{\hat q}_b
            \gets \mathbf{q}_b + \mathbf{k}
            \bmod{2^{128}}$\\
        $\mathbf{\hat m}_b
            \gets \mathbf{m}_b \oplus (\mathbf{p}_b + \mathbf{q}_b
            \bmod{2^{128}})$\\
    }
    \caption{\baheem\ encryption}
    \label{alg_enc}
\end{algorithm}

\begin{algorithm}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{$
        \mathbf{k}, 
        (\mathbf{\hat p}_0, \mathbf{\hat q}_0, \mathbf{\hat m}_0),
        (\mathbf{\hat p}_1, \mathbf{\hat q}_1, \mathbf{\hat m}_1),
        \ldots
    $}
    \Output{$\mathbf{m}_0, \mathbf{m}_1, \ldots$}
    \hrulefill\\
    \For{$b \in (0, 1, \ldots, \lceil\frac{|\mathbf{m}|}{128}\rceil-1)$}{
        $\mathbf{p}_b
            \gets \mathbf{\hat p}_b - \mathbf{k}
            \bmod{2^{128}}$\\
        $\mathbf{q}_b
            \gets \mathbf{\hat q}_b - \mathbf{k}
            \bmod{2^{128}}$\\
        $\mathbf{m}_b
            \gets \mathbf{\hat m}_b \oplus (\mathbf{p}_b + \mathbf{q}_b
            \bmod{2^{128}})$\\
    }
    \caption{\baheem\ decryption}
    \label{alg_dec}
\end{algorithm}

\section{Security Analysis}
The \baheem\ encryption is essentially the \gls{xor} cryptosystem:
\[
    \mathbf{\hat m}_b \gets \mathbf{m}_b \oplus
    \underbrace{
        (\mathbf{p}_b + \mathbf{q}_b \bmod{2^{128}})
    }_{\text{Encryption pad}}
\]

It trivially follows from Shannon's perfect secrecy proof of the \gls{otp}
\cite{perfect_secrecy} that \baheem\ is secure if and only if its
encryption pad maintains its key's entropy as shown in
\cref{eq_security_hinge}, even if the adversary knows $\mathbf{\hat p}_b$,
$\mathbf{\hat q}_b$, $\mathbf{\hat m}_b$ and the cleartext message
$\mathbf{m}_b$.

\begin{equation}
    \begin{split}
        &\entropy(
            \mathbf{k}
            | \mathbf{\hat p}_b,
              \mathbf{\hat q}_b,
              \mathbf{\hat m}_b,
              \mathbf{m}_b
        ) \\
        =&\entropy(
            \mathbf{k}
            | \mathbf{\hat p}_b,
              \mathbf{\hat q}_b,
              \mathbf{p}_b + \mathbf{q}_b \bmod{2^{128}}
        ) \\
        =&\entropy(\mathbf{k})
    \end{split}
    \label{eq_security_hinge}
\end{equation}

To simplify the analysis, suppose that the size of a block in \baheem\ is
$3$ bits only, and that the cleartext block $\mathbf{m}_b$ is known to the
adversary, which implies that the adversary can trivially know that:
\[
    \mathbf{p}_b + \mathbf{q}_b \bmod{2^3}
    = \mathbf{\hat m}_b \oplus \mathbf{m}_b
\]
in addition to adversary's knowledge of the public variables $\mathbf{\hat
p}_b$ and $\mathbf{\hat q}_b$. More specifically, suppose that the
adversary found that:
\begin{align*}
    0&=\mathbf{\hat p}_b = \mathbf{p}_b + \mathbf{k} \bmod{2^3}  \\
    3&=\mathbf{\hat q}_b = \mathbf{q}_b + \mathbf{k} \bmod{2^3}  \\
    5&=\qquad\             \mathbf{p}_b + \mathbf{q}_b \bmod{2^3}\\
\end{align*}

Then, the question is:  will this information reduce the space from which
the key $\mathbf{k}$ is chosen from?  In other words, what are the possible
values of $\mathbf{k}$ that can lead to the outputs $0$, $3$ and $5$ above?
\Cref{tbl_3bit_add} visualises this.

\begin{table}[tbh]
\centering
\begin{NiceTabular}{p{.1em}c|cccccccc}[colortbl-like]
    \        &&&&& $\mathcal{Y}$ &&&& \\
             &   &     0 &     1 &     2 &     3 &     4 &     5 &     6 &     7 \\\hline
             & 0 & \pq 0 &     1 &     2 & \qh 3 &     4 & \ph 5 &     6 &     7 \\
             & 1 &     1 &     2 & \qh 3 &     4 & \ph 5 &     6 &     7 & \pq 0 \\
             & 2 &     2 & \qh 3 &     4 & \ph 5 &     6 &     7 & \pq 0 &     1 \\
$\mathcal{X}$& 3 & \qh 3 &     4 & \ph 5 &     6 &     7 & \pq 0 &     1 &     2 \\
             & 4 &     4 & \ph 5 &     6 &     7 & \pq 0 &     1 &     2 & \qh 3 \\
             & 5 & \ph 5 &     6 &     7 & \pq 0 &     1 &     2 & \qh 3 &     4 \\
             & 6 &     6 &     7 & \pq 0 &     1 &     2 & \qh 3 &     4 & \ph 5 \\
             & 7 &     7 & \pq 0 &     1 &     2 & \qh 3 &     4 & \ph 5 &     6 \\
\end{NiceTabular}
\caption{Exhaustive unsigned $3$-bit addition.  For a given output
$\mathbf{x} + \mathbf{y} \bmod{2^3}$, there are $2^3$ many possible input
values of $(\mathbf{x}, \mathbf{y}) \in \mathcal{X}\times\mathcal{Y}$ that
map to $\mathbf{x} + \mathbf{y} \bmod{2^3}$.}
\label{tbl_3bit_add}
\end{table}

As shown in \cref{tbl_3bit_add}, the total number of horizontal, or
vertical, intersections that simultaneously cross all of the outputs $0$,
$3$ and $5$, remain $2^3$.  Meaning, the total number of values of
$\mathbf{k}$ that could lead to the outputs remains $2^3$.

This $3$-bit example can be trivially extended by induction to show that
the same conclusions hold even with a $128$-bit unsigned addition and any
other output numbers than $0$, $3$ and $5$.

Therefore, we can conclude that adversary's knowledge of the public
variables $\mathbf{\hat p}_b$, $\mathbf{\hat q}_b$, $\mathbf{\hat m}_b$ and
the cleartext $\mathbf{m}_b$, which leads to deducing $\mathbf{p}_b +
\mathbf{q}_b \bmod{2^{128}}$, can not reduce $\entropy(\mathbf{k})$.

Since $\mathbf{\hat p}_b$, $\mathbf{\hat q}_b$, $\mathbf{\hat m}_b$ and the
cleartext $\mathbf{m}_b$ are exhaustively all of the outputs of \baheem\
that can be accessible to an adversary, and since they do not reduce
\baheem's key space, therefore no cryptanalysis can reduce the entropy
\baheem's encryption pad below $\entropy(\mathbf{k})$.

\begin{lemma}[Secure private values]
    \[\begin{split}
        &\entropy(
            \mathbf{k}
            | \mathbf{\hat p}_b,
              \mathbf{\hat q}_b,
              \mathbf{\hat m}_b,
              \mathbf{m}_b
        ) \\
        =&\entropy(
            \mathbf{p}
            | \mathbf{\hat p}_b,
              \mathbf{\hat q}_b,
              \mathbf{\hat m}_b,
              \mathbf{m}_b
        ) \\
        =&\entropy(
            \mathbf{q}
            | \mathbf{\hat p}_b,
              \mathbf{\hat q}_b,
              \mathbf{\hat m}_b,
              \mathbf{m}_b
        ) \\
        =&\entropy(\mathbf{k})
    \end{split}\]
    \label{thrm_baheem_secure_private_values}
\end{lemma}

\begin{lemma}[Secure encryption pad]
    \[
        \entropy(
            \mathbf{p} + \mathbf{q} \bmod{2^{128}}
            | \mathbf{\hat p}_b,
              \mathbf{\hat q}_b,
              \mathbf{\hat m}_b,
              \mathbf{m}_b
        )
        = \entropy(\mathbf{k})
    \]
    \label{thrm_baheem_secure_encryption_pad}
\end{lemma}

Since \baheem\ is an \gls{xor} cryptosystem, and since its encryption pad
is secure (\cref{thrm_baheem_secure_encryption_pad}), therefore it has to
follow by Shannon's perfect secrecy \cite{perfect_secrecy} that \baheem's
encryption is secure as well.

\begin{theorem}[Secure encryption]
    \[
        \entropy(
            \mathbf{m}_b
            | \mathbf{\hat p}_b,
              \mathbf{\hat q}_b,
              \mathbf{\hat m}_b
        )
        = \min(\entropy(\mathbf{m}_b), \entropy(\mathbf{k}))
    \]
    \label{thrm_baheem_secure}
\end{theorem}

\begin{note}
    \baheem\ does not have perfect secrecy, as this requires an impractical
    key that is as long as the message itself.  \baheem\ rather has a
    $\entropy(\mathbf{k})$-bit security.  Shannon's proof of perfect
    secrecy of the \gls{otp} is cited only for its relevance in proving
    \baheem's $\entropy(\mathbf{k})$-bit security as both of them are
    \gls{xor} cryptosystems.
\end{note}


\section{Implementation Examples}
\subsection{C Functions}
In this example, the caller is expected to initialise a $128$ bits key
$\mathbf{k}$, a pair of random pads, $\mathbf{p}$ and $\mathbf{q}$, each of
which is $\mathtt{len} \times 128$ bits long, in order to encrypt a
$\mathtt{len} \times 128$ bits long cleartext message $\mathbf{m}$. The
encryption happens in-place, so the caller does not have to allocate
separate memory for the output. Since $128$-bit wide CPU instructions are
not common, this code operates in $64$-bit basis, each time with a
different $64$-bit part of the key.

\begin{verbatim}
void baheem_enc(
    uint64_t *k, /* 128bit pre-shared key */
    uint64_t *p, /* random pad 1          */
    uint64_t *q, /* random pad 2          */
    uint64_t *m, /* message               */
    size_t  len  /* length of m = p = q   */
) {
    size_t i;
    for (i = 0; i < len; i += 2) {
        m[i]   ^= p[i]   + q[i];
        m[i+1] ^= p[i+1] + q[i+1];
        p[i]   += k[0];
        q[i]   += k[0];
        p[i+1] += k[1];
        q[i+1] += k[1];
    }
}
\end{verbatim}
Likewise, the following is an example implementing the corresponding
in-place decryption function.
\begin{verbatim}
void baheem_dec(... same input ...) {
    size_t i;
    for (i = 0; i < len; i += 2) {
        p[i]   -= k[0];
        q[i]   -= k[0];
        p[i+1] -= k[1];
        q[i+1] -= k[1];
        m[i]   ^= p[i]   + q[i];
        m[i+1] ^= p[i+1] + q[i+1];
    }
}
\end{verbatim}


\subsection{A File Encryption Tool}
\alyal\ is an single-threaded implementation to demonstrate \baheem's
practical utility with real-world scenarios.  Internally, Alyal uses the
\texttt{baheem\_enc} and \texttt{baheem\_dec} functions that were presented
earlier in this section.

\subsubsection{Installation}
\begin{verbatim}
git clone \
  https://codeberg.org/rajululkahf/alyal
cd alyal
make
make test
\end{verbatim}

\subsubsection{Usage}

\begin{verbatim}
alyal (enc|dec) IN OUT [TRNG]
alyal help
\end{verbatim}

To encrypt a cleartext file \texttt{a} and save it as file \texttt{b}:
\begin{verbatim}
alyal enc a b
\end{verbatim}

To decrypt the latter back to its cleartext form and save it as file
\texttt{c}:
\begin{verbatim}
alyal dec b c
\end{verbatim}

\subsubsection{Benchmark}
This is a benchmark that was performed on a computer with a 3.4GHz Intel
Core i5-3570K CPU, 32GB RAM, 7200 RPM hard disks, Linux
5.17.4-gentoo-x86-64, and OpenSSL 1.1.1n.

\begin{table}[tbh]
    \centering
    \begin{tabular}{rcll}
                & OpenSSL            & \multicolumn{2}{c}{\alyal}                \\
                & ChaCha20           & \multicolumn{2}{c}{\baheem}               \\
                &                    & \texttt{/dev/random} & \texttt{file.rand} \\\hline
        Encrypt & \textbf{0.87} secs & 3.91 secs            & 1.40 secs          \\
        500MB   & \textbf{1.04} secs & 4.25 secs            & 1.82 secs          \\
                & \textbf{1.04} secs & 4.27 secs            & 1.73 secs          \\\hline
        Decrypt & 0.90 secs          & \multicolumn{2}{c}{\textbf{0.64} secs}    \\
        500MB   & 1.06 secs          & \multicolumn{2}{c}{\textbf{0.89} secs}    \\
                & 1.06 secs          & \multicolumn{2}{c}{\textbf{0.81} secs}    \\
    \end{tabular}
    \caption{Wall-clock run-time comparison between OpenSSL's ChaCha20, and
    \alyal's \baheem\ implementation with two sources as the \gls{trng}:
    \texttt{/dev/random} and \texttt{file.rand};  the latter is simply
    \texttt{/dev/random} that was prepared in advance.}
    \label{tbl_benchmark}
\end{table}

\Cref{tbl_benchmark} shows that, while the early \baheem\ prototype,
\alyal, has a faster decryption run-time than OpenSSL's ChaCha20, it has
slower encryption run-time. However:
\begin{enumerate}
    \item The differences in run-time are insignificant for most
        applications, which proves \baheem's practical utility in the real
        world.
    \item \baheem's provable security should arguably justify waiting the
        $3$ extra seconds for the 500MB data, specially that many user
        applications involve encrypting much smaller data sizes with
        unnoticeable time difference
    \item Preparing the random bits in advance significantly reduces the
        encryption time as shown with the \texttt{file.rand} case in
        \cref{tbl_benchmark}, and can be optimised further should it be
        prepared in memory.
    \item \alyal\ is currently single-threaded despite \baheem's capacity
        for high parallelism as all blocks are independent. This gives room
        for future versions to be significantly faster.
\end{enumerate}

\section{Conclusions}
This paper proposed \baheem\ with the following properties:
\begin{description}[itemsep=0em]
    \item[Secure.] No cryptanalysis can degrade its
        security below $\min(\entropy(\mathbf{m}), \entropy(\mathbf{k}))$
        bits.

    \item[Fast.] Requires only three additions and a single \gls{xor} per
        encryption or decryption alike.

        Highly parallelisable as the encryption, or decryption, of any bit
        is independent of other bits.

        \baheem's single-threaded prototype, \alyal, outperformed OpenSSL's
        ChaCha20 when decrypting files, despite \baheem's $2$ bits
        overhead, which demonstrates that such overhead is negligible in
        practice.

        While the prototype has a slower encryption run-time due to its use
        of a \gls{trng}, optimising it is trivial by preparing the
        \gls{trng} in advance.

    \item[Simple.] \baheem's simplicity implies fewer expected number of
        implementation bugs, and therefore higher practical security.
\end{description}

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
