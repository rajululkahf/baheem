\documentclass[twocolumn,hidelinks]{article}
\usepackage{orcidlink}
\usepackage[
    type={CC},
    modifier={by},
    version={4.0},
    imagedistance={.5em},
    imagewidth={7em},
    imagemodifier={-80x15},
]{doclicense}
\usepackage[margin=1in,columnsep=1em]{geometry}
\usepackage{enumitem} % to control gaps in description lists
\usepackage{url}
\usepackage[acronym]{glossaries}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{complexity}
\usepackage{cancel}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{nicematrix}
\usepackage{listings}
\usepackage{seqsplit}
\lstset{
    basicstyle=\ttfamily,
    columns=fullflexible,
    commentstyle=\color{gray}\ttfamily,
    keepspaces=true,
}
\newcommand{\baheem}{Băhēm}
\newcommand{\alyal}{Alyal}
\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}
\DeclareMathOperator{\random}{random}
\DeclareMathOperator{\enc}{enc}
\DeclareMathOperator{\dec}{dec}
\DeclareMathOperator{\fread}{read}
\DeclareMathOperator{\fwrite}{write}
\DeclareMathOperator{\entropy}{H}
\makeglossaries
\newacronym{trng}{TRNG}{true random number generator}
\newacronym{otp}{OTP}{one-time pad}
\newacronym{xor}{XOR}{bitwise exclusive-or operation}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\renewcommand\qedsymbol{$\blacksquare$}
\newcommand{\pq}[1]{\cellcolor{red!20}#1}
\newcommand{\ph}[1]{\cellcolor{blue!20}#1}
\newcommand{\qh}[1]{\cellcolor{green!20}#1}
\hyphenation{bottle-neck}
\usepackage{cleveref} % must be loaded last
\begin{document}

\begin{center}
    \Huge
    \baheem\\
    \LARGE
    A Symmetric Cipher with Provable $128$-bit Security\\
    \normalsize
    \vspace{0.5em}
    M. Rajululkahf\,\orcidlink{0000-0001-9061-2921}\footnote{Author's e-mail address: \{last
    name\}\url{@pm.me}}\\
    \vspace{0.5em}
    \footnotesize
    \today
\end{center}

\section*{Overview}
This paper proposes a symmetric cipher, which I name \emph\baheem, with the
following properties:
\begin{description}
    \item[Practical:]  Requires pre-sharing only a $128$-bits key.

    \item[Provably secure:]  No cryptanalysis can degrade its security
        below $\min[\entropy(\mathbf{m}), \entropy(\mathbf{k})]$ bits of
        entropy, even under Grover's algorithm \cite{10.1145/237814.237866}
        or even if it turned out that $\P = \NP$.

    \item[Post-apocalypse:]   Should computers cease to exist or function,
        its encryption and decryption can be done by hand with a pen, a
        paper and some fair dies to roll, with relative ease.  This is
        thanks to it requiring only one addition per-session, and two
        additions and one \gls{xor} per-block.

    \item[Fast:]  Runs fast on common hardware.  Its early single-threaded
        implementation achieved similar run-time speeds to OpenSSL's
        ChaCha20 \cite{chacha20}. Faster speed is easily doable with
        parallelism and better \gls{trng} optimisations.
\end{description}

This comes at a usually-negligible cost of having a $128 +
2|\mathbf{m}|$-bit ciphertext output for a $|\mathbf{m}|$-bit cleartext
input; since space is usually not a bottleneck for most applications. 

\baheem\ is the only symmetric cipher to-date that is \emph{practical} and
\emph{provably secure}.  Other ciphers are only one of them, but not both.
For example, the \gls{otp} is provably secure but usually impractical, as
it requires pre-sharing a key that is as large as the message to encrypt.
On the other hand, state of art ciphers, such as ChaCha20 \cite{chacha20}
or AES \cite{aes}, are practical but not provably secure.

\blfootnote{\seqsplit{\\
EF91FF90DF73A9D76E4841C76D5CB15E7E909C309B307BED15BFB4
E1183B6B9903FA78447E87F166F93B002803B99C0C72C479C253E3
D7A5D6BDF320DC0EDBDA}}
\blfootnote{\vspace{-1em}\doclicenseThis}
\vfill
\break

\section*{Declarations}
All data used in this study is included in this paper.  The latest version
of this paper can be found
here\footnote{\url{https://codeberg.org/rajululkahf/baheem}}, and the
latest version of the implementation can be found
here\footnote{\url{https://codeberg.org/rajululkahf/alyal}}.

\section*{Notation}
\begin{description}
    \item[$\entropy(\mathbf{x})$:]  Shannon's entropy of random variable
        $\mathbf{x}$.

    \item[$\mathbf{x} + \mathbf{y} \bmod{2^{128}}$:]  Unsigned $128$-bit
        addition.

    \item[$\random(128)$:]  $128$ bits generated by a \gls{trng}.

    \item[$\mathbf{k}$:]  $128$-bit pre-shared secret key.  Must seem
        random and uniformly distributed with large enough
        $\entropy(\mathbf{k})$.  Ideally, $\mathbf{k} = \random(128)$.

    \item[$\mathbf{m}$:]  A cleartext message of $|\mathbf{m}|$ many bits.

    \item[$\lceil\frac{|\mathbf{m}|}{128}\rceil$:]  Number of $128$-bit
        blocks in cleartext $\mathbf{m}$.

    \item[$\mathbf{m}_b$:]  The $b^{\text{th}}$ $128$-bit block from
        $\mathbf{m}$.  In other words: $\mathbf{m}_0 \Vert \mathbf{m}_1
        \Vert \ldots \Vert
        \mathbf{m}_{\lceil\frac{|\mathbf{m}|}{128}\rceil} = \mathbf{m}$.

    \item[$\mathbf{s} = \random(128)$:]  Session key.

    \item[$\mathbf{p}_b = \random(128)$:]  Pad key of the $b^{\text{th}}$
        block.

    \item[$\mathbf{\hat s}, \mathbf{\hat p}_b, \mathbf{\hat m}_b$:]
        Encrypted $\mathbf{s}$, $\mathbf{p}_b$ and $\mathbf{m}_b$,
        respectively.
\end{description}

\tableofcontents

\section{Introduction}
Today's state of art symmetric ciphers, such as ChaCha20 or AES, are
attractive for their practicality (requiring only a small, say, $256$-bit
key to pre-share), and for their probable security which is supported by
the failure of the many attempts to break them so far.

However, it remains unknown whether they are actually secure.  It is even
known if it is possible for them to be secure at all, since it remains
unknown whether $\P \ne \NP$. This uncertainty about their security is
quite risky, as encrypted sensitive data is often exposed over public
networks.  Should such ciphers be discovered to be broken, one can decrypt
the previously exposed sensitive data.

On the other hand, Shannon's \gls{otp} is more than just provably secure,
as it satisfies the higher criteria of having \emph{perfect secrecy}; that
is, no cryptanalysis can degrade its security below $\entropy(\mathbf{m})$
many bits.

However, the \gls{otp} is usually impractical as it requires the
communicating parties to exchange keys that are as large as the size of the
messages that they will be exchanging in the future.  This often implies
the necessity to exchange many gigabytes, or terabytes, of truly random
bits in advance of the communication, which is too difficult to satisfy
with most application scenarios.

Due to \gls{otp}'s impractically, most applications choose to rather adopt
the \emph{practically} secure (but not provably) ciphers like ChaCha20 or
AES, in order to avoid the unscalable constraint of having to exchange
large random bits in advance of their communication.



\section{Proposed Algorithm: \baheem}
\Cref{alg_enc,alg_dec} show \baheem's encryption and decryption by which
the process is repeated over every $128$-bit blocks of $\mathbf{m}$:
$\mathbf{m}_0, \mathbf{m}_1, \ldots,
\mathbf{m}_{\lceil\frac{|\mathbf{m}|}{128}\rceil}$.

\begin{algorithm}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{$\mathbf{k}, \mathbf{m}_0, \mathbf{m}_1, \ldots$}
    \Output{$
        \mathbf{\hat s},
        (\mathbf{\hat p}_0, \mathbf{\hat m}_0),
        (\mathbf{\hat p}_1, \mathbf{\hat m}_1),
        \ldots
    $}
    \hrulefill\\
    $\mathbf{s} \gets \random(128)$\\
    $\mathbf{\hat s} \gets \mathbf{s} + \mathbf{k} \bmod{2^{128}}$\\
    \For{$b \in (0, 1, \ldots, \lceil\frac{|\mathbf{m}|}{128}\rceil-1)$}{
        $\mathbf{p}_b \gets \random(128)$\\
        $\mathbf{\hat p}_b
            \gets \mathbf{p}_b + \mathbf{k}
            \bmod{2^{128}}$\\
        $\mathbf{\hat m}_b
            \gets \mathbf{m}_b \oplus (\mathbf{p}_b + \mathbf{s}
            \bmod{2^{128}})$\\
    }
    \caption{\baheem\ encryption}
    \label{alg_enc}
\end{algorithm}

\begin{algorithm}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \Input{$
        \mathbf{k},
        \mathbf{\hat s},
        (\mathbf{\hat p}_0, \mathbf{\hat m}_0),
        (\mathbf{\hat p}_1, \mathbf{\hat m}_1),
        \ldots
    $}
    \Output{$\mathbf{m}_0, \mathbf{m}_1, \ldots$}
    \hrulefill\\
    $\mathbf{s} \gets \mathbf{\hat s} - \mathbf{k} \bmod{2^{128}}$\\
    \For{$b \in (0, 1, \ldots, \lceil\frac{|\mathbf{m}|}{128}\rceil-1)$}{
        $\mathbf{p}_b
            \gets \mathbf{\hat p}_b - \mathbf{k}
            \bmod{2^{128}}$\\
        $\mathbf{m}_b
            \gets \mathbf{\hat m}_b \oplus (\mathbf{p}_b + \mathbf{s}
            \bmod{2^{128}})$\\
    }
    \caption{\baheem\ decryption}
    \label{alg_dec}
\end{algorithm}

\section{Security Analysis}
The \baheem\ encryption is essentially the \gls{xor} cryptosystem:
\[
    \mathbf{\hat m}_b \gets \mathbf{m}_b \oplus
    \underbrace{
        (\mathbf{p}_b + \mathbf{s} \bmod{2^{128}})
    }_{\text{One-time encryption pad}}
\]

It trivially follows from Shannon's perfect secrecy proof of the \gls{otp}
\cite{perfect_secrecy} that \baheem\ is secure if its encryption pad
maintains its security.

To simplify the analysis, suppose that the size of a block in \baheem\ is
$3$ bits only, and that the cleartext block $\mathbf{m}_b$ is known to the
adversary, which implies that the adversary can trivially know that:
\[
    \mathbf{p}_b + \mathbf{s} \bmod{2^3}
    = \mathbf{\hat m}_b \oplus \mathbf{m}_b
\]
in addition to adversary's knowledge of the public variables $\mathbf{\hat
s}$ and $\mathbf{\hat p}_b$. More specifically, suppose that the
adversary found that:
\begin{align*}
    0&=\mathbf{\hat s} = \mathbf{s} + \mathbf{k} \bmod{2^3}  \\
    3&=\mathbf{\hat p}_b = \mathbf{p}_b + \mathbf{k} \bmod{2^3}  \\
    5&=\mathbf{\hat m}_b \oplus \mathbf{m}_b
            = \mathbf{p}_b + \mathbf{s} \bmod{2^3}\\
\end{align*}

Then, the question is:  will this information reduce the space from which
the key $\mathbf{k}$ is chosen from?  In other words, what are the possible
values of $\mathbf{k}$ that can lead to the outputs $0$, $3$ and $5$ above?
\Cref{tbl_3bit_add} visualises this.

\begin{table}[tbh]
\centering
\begin{NiceTabular}{p{.1em}c|cccccccc}[colortbl-like]
    \        &&&&& $\mathcal{Y}$ &&&& \\
             &   &     0 &     1 &     2 &     3 &     4 &     5 &     6 &     7 \\\hline
             & 0 & \pq 0 &     1 &     2 & \qh 3 &     4 & \ph 5 &     6 &     7 \\
             & 1 &     1 &     2 & \qh 3 &     4 & \ph 5 &     6 &     7 & \pq 0 \\
             & 2 &     2 & \qh 3 &     4 & \ph 5 &     6 &     7 & \pq 0 &     1 \\
$\mathcal{X}$& 3 & \qh 3 &     4 & \ph 5 &     6 &     7 & \pq 0 &     1 &     2 \\
             & 4 &     4 & \ph 5 &     6 &     7 & \pq 0 &     1 &     2 & \qh 3 \\
             & 5 & \ph 5 &     6 &     7 & \pq 0 &     1 &     2 & \qh 3 &     4 \\
             & 6 &     6 &     7 & \pq 0 &     1 &     2 & \qh 3 &     4 & \ph 5 \\
             & 7 &     7 & \pq 0 &     1 &     2 & \qh 3 &     4 & \ph 5 &     6 \\
\end{NiceTabular}
\caption{Exhaustive unsigned $3$-bit addition.  For a given output
$\mathbf{x} + \mathbf{y} \bmod{2^3}$, there are $2^3$ many possible input
values of $(\mathbf{x}, \mathbf{y}) \in \mathcal{X}\times\mathcal{Y}$ that
map to $\mathbf{x} + \mathbf{y} \bmod{2^3}$.}
\label{tbl_3bit_add}
\end{table}

As shown in \cref{tbl_3bit_add}, the total number of horizontal, or
vertical, intersections that simultaneously cross all of the outputs $0$,
$3$ and $5$, remain $2^3$.  Meaning, the total number of values of
$\mathbf{k}$ that could lead to the outputs remains $2^3$.

This $3$-bit example can be trivially extended by induction to show that
the same conclusions hold even with a $128$-bit unsigned addition and any
other output numbers than $0$, $3$ and $5$.

Therefore, we can conclude that adversary's knowledge of the public
variables $\mathbf{\hat s}$, $\mathbf{\hat p}_b$, $\mathbf{\hat m}_b$ and
the cleartext $\mathbf{m}_b$, which leads to deducing $\mathbf{p}_b +
\mathbf{s} \bmod{2^{128}}$, can not reduce the space from which
$\mathbf{k}$, $\mathbf{s}$ and $\mathbf{p}_b$ are sampled.

If $\mathbf{k}$, $\mathbf{s}$ and $\mathbf{p}_b$ are generated by a
\gls{trng}, then any of the $2^{128}$ many possiblities are equally likely
to correspond to the actual values of $\mathbf{k}$, $\mathbf{s}$ and
$\mathbf{p}_b$.  In other words:
\[
    \entropy(\mathbf{k},\mathbf{s},\mathbf{p}_b
        | \mathbf{\hat s},
          \mathbf{\hat p}_b,
          \mathbf{\hat m}_b,
          \mathbf{m}_b
    )
    = 128
\]

However, since $\mathbf{k}$ could be derived from a password, such that it
looks random, but with an entropy $\entropy(\mathbf{k}) \le 128$, and since
finding any of the numbers $\mathbf{k}$, $\mathbf{s}$ and $\mathbf{p}_b$
deterministically leads to finding the others, therefore it follows that:
\[
    \entropy(\mathbf{k},\mathbf{s},\mathbf{p}_b
        | \mathbf{\hat s},
          \mathbf{\hat p}_b,
          \mathbf{\hat m}_b,
          \mathbf{m}_b
    )
    = \entropy(\mathbf{k})
\]

The numbers $\mathbf{s}$ and $\mathbf{p}_b$ are generated by a \gls{trng}
by definition, therefore the weakest element in the chain can only be
$\mathbf{k}$.

Since the public variables $\mathbf{\hat s}$, $\mathbf{\hat p}_b$ and
$\mathbf{\hat m}_b$, and the cleartext $\mathbf{m}_b$ are exhaustively all
of the outputs of \baheem\ that can be accessible to an adversary, and
since they can not reduce \baheem's private variables' space below
$\entropy(\mathbf{k})$, therefore no cryptanalysis can reduce their entropy
below $\entropy(\mathbf{k})$.

\begin{lemma}[Secure private values]
    \[
        \entropy(\mathbf{k},\mathbf{s},\mathbf{p}_b
            | \mathbf{\hat s},
              \mathbf{\hat p}_b,
              \mathbf{\hat m}_b,
              \mathbf{m}_b
        )
        = \entropy(\mathbf{k})
    \]
    \label{thrm_baheem_secure_private_values}
\end{lemma}

It is trivially implied from \cref{thrm_baheem_secure_private_values} that,
since the private values $\mathbf{s}$ and $\mathbf{p}_b$ maintain an
entropy of $\entropy(\mathbf{k})$, so does their $128$-bit summation
$\mathbf{s} + \mathbf{p}_b \bmod{2^{128}}$, which is \baheem's \gls{xor}
encryption pad.  Therefore, \baheem's encryption pad has to be secure as
well.

\begin{lemma}[Secure encryption pad]
    \[
        \entropy(
            \mathbf{s} + \mathbf{p}_b \bmod{2^{128}}
            | \mathbf{\hat s},
              \mathbf{\hat p}_b,
              \mathbf{\hat m}_b
        )
        = \min[\entropy(\mathbf{m}_b), \entropy(\mathbf{k})]
    \]
    \label{thrm_baheem_secure_encryption_pad}
\end{lemma}

Since \baheem\ is an \gls{xor} cryptosystem, and since its encryption pad
is $\entropy(\mathbf{k})$-bits secure
(\cref{thrm_baheem_secure_encryption_pad}), therefore it necessarily
follows by Shannon's perfect secrecy \cite{perfect_secrecy} that \baheem's
encryption is either $\entropy(\mathbf{k})$-bits secure, or
$\entropy(\mathbf{m}_b)$-bits secure, whichever is smaller.

\begin{theorem}[Secure encryption]
    \[
        \entropy(
            \mathbf{m}_b
            | \mathbf{\hat s},
              \mathbf{\hat p}_b,
              \mathbf{\hat m}_b
        )
        = \min[\entropy(\mathbf{m}_b), \entropy(\mathbf{k})]
    \]
    \label{thrm_baheem_secure}
\end{theorem}

\begin{description}
    \item[Note:] \baheem\ does not aim at achieving perfect secrecy, as
        perfect secrecy requires a usually-impractical key that is as long
        as the length $|\mathbf{m}|$ of the cleartext message $\mathbf{m}$
        itself, with an unnecessarily too large upper security bound that
        is worth $|\mathbf{m}|$ many bits of entropy.

        \baheem\ rather aims at achieving a security that is worth
        $\min[\entropy(\mathbf{m}_b), \entropy(\mathbf{k})]$ entropy bits.
        Unlike the \gls{otp}, this is \emph{practically} secure and only
        requires pre-sharing a small $128$-bit key.

        Shannon's proof of perfect secrecy of the \gls{otp} is cited only
        for its relevance as an \gls{xor} cryptosystem.
\end{description}


\section{Benchmark}
This is a benchmark that was performed on a computer with a 3.4GHz Intel
Core i5-3570K CPU, 32GB RAM, 7200 RPM hard disks, Linux
5.17.4-gentoo-x86-64, OpenSSL 1.1.1n and Alyal v3.

\begin{table}[tbh]
    \centering
    \begin{tabular}{rcll}
                & OpenSSL            & \multicolumn{2}{c}{\alyal}                \\
                & ChaCha20           & \multicolumn{2}{c}{\baheem}               \\
                &                    & \texttt{/dev/random} & \texttt{file.rand} \\\hline
        Encrypt & \textbf{0.90} secs & 2.58 secs            & 1.38 secs          \\
        500MB   & \textbf{1.06} secs & 2.60 secs            & 1.35 secs          \\
                & \textbf{1.04} secs & 2.58 secs            & 1.35 secs          \\\hline
        Decrypt & 0.89 secs          & \multicolumn{2}{c}{\textbf{0.82} secs}    \\
        500MB   & 1.12 secs          & \multicolumn{2}{c}{\textbf{0.87} secs}    \\
                & 1.06 secs          & \multicolumn{2}{c}{\textbf{0.82} secs}    \\
    \end{tabular}
    \caption{Wall-clock run-time comparison between OpenSSL's ChaCha20, and
    \alyal's \baheem\ implementation with two sources as the \gls{trng}:
    \texttt{/dev/random} and \texttt{file.rand};  the latter is simply
    \texttt{/dev/random} that was prepared in advance.}
    \label{tbl_benchmark}
\end{table}

\Cref{tbl_benchmark} shows that, while the early \baheem\ prototype,
\alyal, has a faster decryption run-time than OpenSSL's ChaCha20, it has
a slower encryption run-time. However:
\begin{enumerate}
    \item The differences in run-time are insignificant for most
        applications, which proves \baheem's practical utility in the real
        world.
    \item \baheem's provable security should arguably justify waiting the
        extra seconds, or fractions of seconds in case the \gls{trng} is
        prepared in advance, for the 500MB data, specially that many user
        applications involve encrypting much smaller data sizes with
        unnoticeable time difference
    \item Preparing the random bits in advance significantly reduces the
        encryption time as shown with the \texttt{file.rand} case in
        \cref{tbl_benchmark}, and can be optimised further should it be
        prepared in memory.
    \item \alyal\ is currently single-threaded despite \baheem's capacity
        for high parallelism as all blocks are independent. This gives room
        for future versions to be significantly faster.
\end{enumerate}

\section{Conclusions}
This paper proposed \baheem\ with the following properties:
\begin{description}[itemsep=0em]
    \item[Provably secure:] No cryptanalysis can degrade its
        security below $\min[\entropy(\mathbf{m}), \entropy(\mathbf{k})]$
        bits.

    \item[Fast:] Requires only three additions (one per-session, two
        per-block) and a single \gls{xor} per encryption or decryption
        alike.

        Highly parallelisable as the encryption, or decryption, of any bit
        is independent of other bits.

        \baheem's single-threaded prototype, \alyal, outperformed OpenSSL's
        ChaCha20 when decrypting files, despite \baheem's $1$-bit overhead,
        which demonstrates that such overhead is negligible in practice.

        While the prototype has a slower encryption run-time due to its use
        of a \gls{trng}, optimising it is trivial by preparing the
        \gls{trng} in advance.

    \item[Simple:] \baheem's simplicity implies fewer expected number of
        implementation bugs, and therefore higher practical security.

        Another interesting advantage of this simplicity is that it allows
        \baheem\ to be used with a mere pen and a paper should one lack a
        computer, such as the case with post-apocalyptic scenarios.

        For example, in a post-apocalyptic scenario, one can generate the
        random numbers $\mathbf{p}_b$ and $\mathbf{q}_b$ by rolling dies
        enough number of times until adequate entropy is obtained, and then
        using a pen and a paper to calculate the ciphertext as per
        \cref{alg_enc}.

        Since \baheem\ does not require repeating rounds over and over,
        \baheem\ is significantly simpler to perform using a pen and a
        paper than, say, ChaCha20, AES \cite{aes}, etc, which require many
        repeated rounds that make it too tedious for a human to perform by
        the pen and paper method.
\end{description}

\bibliographystyle{unsrt}
\bibliography{references}

\appendix
\section{Implementation Examples}
\subsection{Pens, Papers and Fair Dies}

\subsection{C Functions}
\Cref{lst_baheem_session_enc,lst_baheem_session_dec} show example C
functions for encrypting and decrypting session keys.

\Cref{lst_baheem_block_enc,lst_baheem_block_dec} show the same but for
encrypting and decrypting cleartext and ciphertext blocks, respectively.

In these examples, all encryptions and decryptions happen in-place whenever
possible, so the caller does not have to allocate separate memory for the
output.  The only excepton is \cref{lst_baheem_session_enc}, where the
unencrypted session key is required to encrypt the subsequent cleartext
blocks. Also, since $128$-bit wide CPU instructions are not common, the
examples operate in $64$-bit basis, each time with a different $64$-bit
part of the pre-shared and session keys.

\begin{lstlisting}[language=C, caption=Session key encryption function
                   example., label=lst_baheem_session_enc]
void baheem_session_enc(
    uint64_t *k,    /* pre-shared key */
    uint64_t *s,    /* session key    */
    uint64_t *s_enc /* encrypted s    */
) {
    s_enc[0] = s[0] + k[0];
    s_enc[1] = s[1] + k[1];
}
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Session key decryption function
                   example., label=lst_baheem_session_dec]
void baheem_session_dec(
    uint64_t *k, /* pre-shared key */
    uint64_t *s  /* session key    */
) {
    s[0] -= k[0];
    s[1] -= k[1];
}
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Block encryption function example.,
                   label=lst_baheem_block_enc]
void baheem_block_enc(
    uint64_t *k, /* pre-shared key    */
    uint64_t *s, /* session key       */
    uint64_t *p, /* pad keys          */
    uint64_t *m, /* message           */
    size_t  len  /* length of m and p */
) {
    size_t i;
    for (i = 0; i < len; i += 2) {
        m[i]   ^= p[i]   + s[0];
        m[i+1] ^= p[i+1] + s[1];
        p[i]   += k[0];
        p[i+1] += k[1];
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Block decryption function example.,
                   label=lst_baheem_block_dec]
void baheem_block_dec(
    uint64_t *k, /* pre-shared key    */
    uint64_t *s, /* session key       */
    uint64_t *p, /* pad keys          */
    uint64_t *m, /* message           */
    size_t  len  /* length of m and p */
) {
    size_t i;
    for (i = 0; i < len; i += 2) {
        p[i]   -= k[0];
        p[i+1] -= k[1];
        m[i]   ^= p[i]   + s[0];
        m[i+1] ^= p[i+1] + s[1];
    }
}
\end{lstlisting}

\subsection{A File Encryption Tool}
\alyal\ is an single-threaded implementation to demonstrate \baheem's
practical utility with real-world scenarios.  Internally, Alyal uses the
functions in
\cref{lst_baheem_session_enc,lst_baheem_session_dec,lst_baheem_block_enc,lst_baheem_block_dec}.

\subsubsection{Installation}
\begin{verbatim}
git clone \
  https://codeberg.org/rajululkahf/alyal
cd alyal
make
make test
\end{verbatim}

\subsubsection{Usage}

\begin{verbatim}
alyal (enc|dec) IN OUT [TRNG]
alyal help
\end{verbatim}

To encrypt a cleartext file \texttt{a} and save it as file \texttt{b}:
\begin{verbatim}
alyal enc a b
\end{verbatim}

To decrypt the latter back to its cleartext form and save it as file
\texttt{c}:
\begin{verbatim}
alyal dec b c
\end{verbatim}

\end{document}
